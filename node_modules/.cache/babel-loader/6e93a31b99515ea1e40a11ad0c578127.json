{"ast":null,"code":"'use strict';\n\nvar _defineProperty = require(\"E:\\\\6 6\\\\React-redux-shopping-web-app\\\\node_modules\\\\@babel\\\\runtime/helpers/defineProperty\");\n\nvar makeRequest = require('./makeRequest');\n\nvar utils = require('./utils');\n\nfunction makeAutoPaginationMethods(self, requestArgs, spec, firstPagePromise) {\n  var promiseCache = {\n    currentPromise: null\n  };\n  var reverseIteration = isReverseIteration(requestArgs);\n  var pagePromise = firstPagePromise;\n  var i = 0; // Search and List methods iterate differently.\n  // Search relies on a `next_page` token and can only iterate in one direction.\n  // List relies on either an `ending_before` or `starting_after` field with\n  // an item ID to paginate and is bi-directional.\n  //\n  // Please note: spec.methodType === 'search' is beta functionality and is\n  // subject to change/removal at any time.\n\n  var getNextPagePromise;\n\n  if (spec.methodType === 'search') {\n    getNextPagePromise = function getNextPagePromise(pageResult) {\n      if (!pageResult.next_page) {\n        throw Error('Unexpected: Stripe API response does not have a well-formed `next_page` field, but `has_more` was true.');\n      }\n\n      return makeRequest(self, requestArgs, spec, {\n        page: pageResult.next_page\n      });\n    };\n  } else {\n    getNextPagePromise = function getNextPagePromise(pageResult) {\n      var lastId = getLastId(pageResult, reverseIteration);\n      return makeRequest(self, requestArgs, spec, _defineProperty({}, reverseIteration ? 'ending_before' : 'starting_after', lastId));\n    };\n  }\n\n  function iterate(pageResult) {\n    if (!(pageResult && pageResult.data && typeof pageResult.data.length === 'number')) {\n      throw Error('Unexpected: Stripe API response does not have a well-formed `data` array.');\n    }\n\n    if (i < pageResult.data.length) {\n      var idx = reverseIteration ? pageResult.data.length - 1 - i : i;\n      var value = pageResult.data[idx];\n      i += 1;\n      return {\n        value: value,\n        done: false\n      };\n    } else if (pageResult.has_more) {\n      // Reset counter, request next page, and recurse.\n      i = 0;\n      pagePromise = getNextPagePromise(pageResult);\n      return pagePromise.then(iterate);\n    }\n\n    return {\n      value: undefined,\n      done: true\n    };\n  }\n\n  function asyncIteratorNext() {\n    return memoizedPromise(promiseCache, function (resolve, reject) {\n      return pagePromise.then(iterate).then(resolve).catch(reject);\n    });\n  }\n\n  var autoPagingEach = makeAutoPagingEach(asyncIteratorNext);\n  var autoPagingToArray = makeAutoPagingToArray(autoPagingEach);\n\n  var autoPaginationMethods = _defineProperty({\n    autoPagingEach: autoPagingEach,\n    autoPagingToArray: autoPagingToArray,\n    // Async iterator functions:\n    next: asyncIteratorNext,\n    return: function _return() {\n      // This is required for `break`.\n      return {};\n    }\n  }, getAsyncIteratorSymbol(), function () {\n    return autoPaginationMethods;\n  });\n\n  return autoPaginationMethods;\n}\n\nmodule.exports.makeAutoPaginationMethods = makeAutoPaginationMethods;\n/**\n * ----------------\n * Private Helpers:\n * ----------------\n */\n\nfunction getAsyncIteratorSymbol() {\n  if (typeof Symbol !== 'undefined' && Symbol.asyncIterator) {\n    return Symbol.asyncIterator;\n  } // Follow the convention from libraries like iterall: https://github.com/leebyron/iterall#asynciterator-1\n\n\n  return '@@asyncIterator';\n}\n\nfunction getDoneCallback(args) {\n  if (args.length < 2) {\n    return undefined;\n  }\n\n  var onDone = args[1];\n\n  if (typeof onDone !== 'function') {\n    throw Error(\"The second argument to autoPagingEach, if present, must be a callback function; received \".concat(typeof onDone));\n  }\n\n  return onDone;\n}\n/**\n * We allow four forms of the `onItem` callback (the middle two being equivalent),\n *\n *   1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n *   2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n *   3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n *   4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n *\n * In addition to standard validation, this helper\n * coalesces the former forms into the latter form.\n */\n\n\nfunction getItemCallback(args) {\n  if (args.length === 0) {\n    return undefined;\n  }\n\n  var onItem = args[0];\n\n  if (typeof onItem !== 'function') {\n    throw Error(\"The first argument to autoPagingEach, if present, must be a callback function; received \".concat(typeof onItem));\n  } // 4. `.autoPagingEach((item, next) => { doSomething(item); next(false); });`\n\n\n  if (onItem.length === 2) {\n    return onItem;\n  }\n\n  if (onItem.length > 2) {\n    throw Error(\"The `onItem` callback function passed to autoPagingEach must accept at most two arguments; got \".concat(onItem));\n  } // This magically handles all three of these usecases (the latter two being functionally identical):\n  // 1. `.autoPagingEach((item) => { doSomething(item); return false; });`\n  // 2. `.autoPagingEach(async (item) => { await doSomething(item); return false; });`\n  // 3. `.autoPagingEach((item) => doSomething(item).then(() => false));`\n\n\n  return function _onItem(item, next) {\n    var shouldContinue = onItem(item);\n    next(shouldContinue);\n  };\n}\n\nfunction getLastId(listResult, reverseIteration) {\n  var lastIdx = reverseIteration ? 0 : listResult.data.length - 1;\n  var lastItem = listResult.data[lastIdx];\n  var lastId = lastItem && lastItem.id;\n\n  if (!lastId) {\n    throw Error('Unexpected: No `id` found on the last item while auto-paging a list.');\n  }\n\n  return lastId;\n}\n/**\n * If a user calls `.next()` multiple times in parallel,\n * return the same result until something has resolved\n * to prevent page-turning race conditions.\n */\n\n\nfunction memoizedPromise(promiseCache, cb) {\n  if (promiseCache.currentPromise) {\n    return promiseCache.currentPromise;\n  }\n\n  promiseCache.currentPromise = new Promise(cb).then(function (ret) {\n    promiseCache.currentPromise = undefined;\n    return ret;\n  });\n  return promiseCache.currentPromise;\n}\n\nfunction makeAutoPagingEach(asyncIteratorNext) {\n  return function\n    /* onItem?, onDone? */\n  autoPagingEach() {\n    var args = [].slice.call(arguments);\n    var onItem = getItemCallback(args);\n    var onDone = getDoneCallback(args);\n\n    if (args.length > 2) {\n      throw Error(\"autoPagingEach takes up to two arguments; received \".concat(args));\n    }\n\n    var autoPagePromise = wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem);\n    return utils.callbackifyPromiseWithTimeout(autoPagePromise, onDone);\n  };\n}\n\nfunction makeAutoPagingToArray(autoPagingEach) {\n  return function autoPagingToArray(opts, onDone) {\n    var limit = opts && opts.limit;\n\n    if (!limit) {\n      throw Error('You must pass a `limit` option to autoPagingToArray, e.g., `autoPagingToArray({limit: 1000});`.');\n    }\n\n    if (limit > 10000) {\n      throw Error('You cannot specify a limit of more than 10,000 items to fetch in `autoPagingToArray`; use `autoPagingEach` to iterate through longer lists.');\n    }\n\n    var promise = new Promise(function (resolve, reject) {\n      var items = [];\n      autoPagingEach(function (item) {\n        items.push(item);\n\n        if (items.length >= limit) {\n          return false;\n        }\n      }).then(function () {\n        resolve(items);\n      }).catch(reject);\n    });\n    return utils.callbackifyPromiseWithTimeout(promise, onDone);\n  };\n}\n\nfunction wrapAsyncIteratorWithCallback(asyncIteratorNext, onItem) {\n  return new Promise(function (resolve, reject) {\n    function handleIteration(iterResult) {\n      if (iterResult.done) {\n        resolve();\n        return;\n      }\n\n      var item = iterResult.value;\n      return new Promise(function (next) {\n        // Bit confusing, perhaps; we pass a `resolve` fn\n        // to the user, so they can decide when and if to continue.\n        // They can return false, or a promise which resolves to false, to break.\n        onItem(item, next);\n      }).then(function (shouldContinue) {\n        if (shouldContinue === false) {\n          return handleIteration({\n            done: true\n          });\n        } else {\n          return asyncIteratorNext().then(handleIteration);\n        }\n      });\n    }\n\n    asyncIteratorNext().then(handleIteration).catch(reject);\n  });\n}\n\nfunction isReverseIteration(requestArgs) {\n  var args = [].slice.call(requestArgs);\n  var dataFromArgs = utils.getDataFromArgs(args);\n  return !!dataFromArgs.ending_before;\n}","map":null,"metadata":{},"sourceType":"script"}