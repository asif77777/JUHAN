{"ast":null,"code":"'use strict';\n\nvar utils = require('./utils');\n\nvar _require = require('./Error'),\n    StripeConnectionError = _require.StripeConnectionError,\n    StripeAuthenticationError = _require.StripeAuthenticationError,\n    StripePermissionError = _require.StripePermissionError,\n    StripeRateLimitError = _require.StripeRateLimitError,\n    StripeError = _require.StripeError,\n    StripeAPIError = _require.StripeAPIError;\n\nvar _require2 = require('./net/HttpClient'),\n    HttpClient = _require2.HttpClient; // Provide extension mechanism for Stripe Resource Sub-Classes\n\n\nStripeResource.extend = utils.protoExtend; // Expose method-creator & prepared (basic) methods\n\nStripeResource.method = require('./StripeMethod');\nStripeResource.BASIC_METHODS = require('./StripeMethod.basic');\nStripeResource.MAX_BUFFERED_REQUEST_METRICS = 100;\nvar MAX_RETRY_AFTER_WAIT = 60;\n/**\n * Encapsulates request logic for a Stripe Resource\n */\n\nfunction StripeResource(stripe, deprecatedUrlData) {\n  this._stripe = stripe;\n\n  if (deprecatedUrlData) {\n    throw new Error('Support for curried url params was dropped in stripe-node v7.0.0. Instead, pass two ids.');\n  }\n\n  this.basePath = utils.makeURLInterpolator(this.basePath || stripe.getApiField('basePath'));\n  this.resourcePath = this.path;\n  this.path = utils.makeURLInterpolator(this.path); // DEPRECATED: This was kept for backwards compatibility in case users were\n  // using this, but basic methods are now explicitly defined on a resource.\n\n  if (this.includeBasic) {\n    this.includeBasic.forEach(function (methodName) {\n      this[methodName] = StripeResource.BASIC_METHODS[methodName];\n    }, this);\n  }\n\n  this.initialize.apply(this, arguments);\n}\n\nStripeResource.prototype = {\n  path: '',\n  // Methods that don't use the API's default '/v1' path can override it with this setting.\n  basePath: null,\n  initialize: function initialize() {},\n  // Function to override the default data processor. This allows full control\n  // over how a StripeResource's request data will get converted into an HTTP\n  // body. This is useful for non-standard HTTP requests. The function should\n  // take method name, data, and headers as arguments.\n  requestDataProcessor: null,\n  // Function to add a validation checks before sending the request, errors should\n  // be thrown, and they will be passed to the callback/promise.\n  validateRequest: null,\n  createFullPath: function createFullPath(commandPath, urlData) {\n    var urlParts = [this.basePath(urlData), this.path(urlData)];\n\n    if (typeof commandPath === 'function') {\n      var computedCommandPath = commandPath(urlData); // If we have no actual command path, we just omit it to avoid adding a\n      // trailing slash. This is important for top-level listing requests, which\n      // do not have a command path.\n\n      if (computedCommandPath) {\n        urlParts.push(computedCommandPath);\n      }\n    } else {\n      urlParts.push(commandPath);\n    }\n\n    return this._joinUrlParts(urlParts);\n  },\n  // Creates a relative resource path with symbols left in (unlike\n  // createFullPath which takes some data to replace them with). For example it\n  // might produce: /invoices/{id}\n  createResourcePathWithSymbols: function createResourcePathWithSymbols(pathWithSymbols) {\n    // If there is no path beyond the resource path, we want to produce just\n    // /<resource path> rather than /<resource path>/.\n    if (pathWithSymbols) {\n      return \"/\".concat(this._joinUrlParts([this.resourcePath, pathWithSymbols]));\n    } else {\n      return \"/\".concat(this.resourcePath);\n    }\n  },\n  _joinUrlParts: function _joinUrlParts(parts) {\n    // Replace any accidentally doubled up slashes. This previously used\n    // path.join, which would do this as well. Unfortunately we need to do this\n    // as the functions for creating paths are technically part of the public\n    // interface and so we need to preserve backwards compatibility.\n    return parts.join('/').replace(/\\/{2,}/g, '/');\n  },\n  // DEPRECATED: Here for backcompat in case users relied on this.\n  wrapTimeout: utils.callbackifyPromiseWithTimeout,\n  _timeoutHandler: function _timeoutHandler(timeout, req, callback) {\n    return function () {\n      var timeoutErr = new TypeError('ETIMEDOUT');\n      timeoutErr.code = 'ETIMEDOUT';\n      req.destroy(timeoutErr);\n    };\n  },\n  _addHeadersDirectlyToObject: function _addHeadersDirectlyToObject(obj, headers) {\n    // For convenience, make some headers easily accessible on\n    // lastResponse.\n    // NOTE: Stripe responds with lowercase header names/keys.\n    obj.requestId = headers['request-id'];\n    obj.stripeAccount = obj.stripeAccount || headers['stripe-account'];\n    obj.apiVersion = obj.apiVersion || headers['stripe-version'];\n    obj.idempotencyKey = obj.idempotencyKey || headers['idempotency-key'];\n  },\n  _makeResponseEvent: function _makeResponseEvent(requestEvent, statusCode, headers) {\n    var requestEndTime = Date.now();\n    var requestDurationMs = requestEndTime - requestEvent.request_start_time;\n    return utils.removeNullish({\n      api_version: headers['stripe-version'],\n      account: headers['stripe-account'],\n      idempotency_key: headers['idempotency-key'],\n      method: requestEvent.method,\n      path: requestEvent.path,\n      status: statusCode,\n      request_id: this._getRequestId(headers),\n      elapsed: requestDurationMs,\n      request_start_time: requestEvent.request_start_time,\n      request_end_time: requestEndTime\n    });\n  },\n  _getRequestId: function _getRequestId(headers) {\n    return headers['request-id'];\n  },\n\n  /**\n   * Used by methods with spec.streaming === true. For these methods, we do not\n   * buffer successful responses into memory or do parse them into stripe\n   * objects, we delegate that all of that to the user and pass back the raw\n   * http.Response object to the callback.\n   *\n   * (Unsuccessful responses shouldn't make it here, they should\n   * still be buffered/parsed and handled by _jsonResponseHandler -- see\n   * makeRequest)\n   */\n  _streamingResponseHandler: function _streamingResponseHandler(requestEvent, callback) {\n    var _this = this;\n\n    return function (res) {\n      var headers = res.getHeaders();\n\n      var streamCompleteCallback = function streamCompleteCallback() {\n        var responseEvent = _this._makeResponseEvent(requestEvent, res.getStatusCode(), headers);\n\n        _this._stripe._emitter.emit('response', responseEvent);\n\n        _this._recordRequestMetrics(_this._getRequestId(headers), responseEvent.elapsed);\n      };\n\n      var stream = res.toStream(streamCompleteCallback); // This is here for backwards compatibility, as the stream is a raw\n      // HTTP response in Node and the legacy behavior was to mutate this\n      // response.\n\n      _this._addHeadersDirectlyToObject(stream, headers);\n\n      return callback(null, stream);\n    };\n  },\n\n  /**\n   * Default handler for Stripe responses. Buffers the response into memory,\n   * parses the JSON and returns it (i.e. passes it to the callback) if there\n   * is no \"error\" field. Otherwise constructs/passes an appropriate Error.\n   */\n  _jsonResponseHandler: function _jsonResponseHandler(requestEvent, callback) {\n    var _this2 = this;\n\n    return function (res) {\n      var headers = res.getHeaders();\n\n      var requestId = _this2._getRequestId(headers);\n\n      var statusCode = res.getStatusCode();\n\n      var responseEvent = _this2._makeResponseEvent(requestEvent, statusCode, headers);\n\n      _this2._stripe._emitter.emit('response', responseEvent);\n\n      res.toJSON().then(function (jsonResponse) {\n        if (jsonResponse.error) {\n          var err; // Convert OAuth error responses into a standard format\n          // so that the rest of the error logic can be shared\n\n          if (typeof jsonResponse.error === 'string') {\n            jsonResponse.error = {\n              type: jsonResponse.error,\n              message: jsonResponse.error_description\n            };\n          }\n\n          jsonResponse.error.headers = headers;\n          jsonResponse.error.statusCode = statusCode;\n          jsonResponse.error.requestId = requestId;\n\n          if (statusCode === 401) {\n            err = new StripeAuthenticationError(jsonResponse.error);\n          } else if (statusCode === 403) {\n            err = new StripePermissionError(jsonResponse.error);\n          } else if (statusCode === 429) {\n            err = new StripeRateLimitError(jsonResponse.error);\n          } else {\n            err = StripeError.generate(jsonResponse.error);\n          }\n\n          throw err;\n        }\n\n        return jsonResponse;\n      }, function (e) {\n        throw new StripeAPIError({\n          message: 'Invalid JSON received from the Stripe API',\n          exception: e,\n          requestId: headers['request-id']\n        });\n      }).then(function (jsonResponse) {\n        _this2._recordRequestMetrics(requestId, responseEvent.elapsed); // Expose raw response object.\n\n\n        var rawResponse = res.getRawResponse();\n\n        _this2._addHeadersDirectlyToObject(rawResponse, headers);\n\n        Object.defineProperty(jsonResponse, 'lastResponse', {\n          enumerable: false,\n          writable: false,\n          value: rawResponse\n        });\n        callback.call(_this2, null, jsonResponse);\n      }, function (e) {\n        return callback.call(_this2, e, null);\n      });\n    };\n  },\n  _generateConnectionErrorMessage: function _generateConnectionErrorMessage(requestRetries) {\n    return \"An error occurred with our connection to Stripe.\".concat(requestRetries > 0 ? \" Request was retried \".concat(requestRetries, \" times.\") : '');\n  },\n  _errorHandler: function _errorHandler(req, requestRetries, callback) {\n    var _this3 = this;\n\n    return function (message, detail) {\n      callback.call(_this3, new StripeConnectionError({\n        message: _this3._generateConnectionErrorMessage(requestRetries),\n        detail: error\n      }), null);\n    };\n  },\n  // For more on when and how to retry API requests, see https://stripe.com/docs/error-handling#safely-retrying-requests-with-idempotency\n  _shouldRetry: function _shouldRetry(res, numRetries, maxRetries, error) {\n    if (error && numRetries === 0 && HttpClient.CONNECTION_CLOSED_ERROR_CODES.includes(error.code)) {\n      return true;\n    } // Do not retry if we are out of retries.\n\n\n    if (numRetries >= maxRetries) {\n      return false;\n    } // Retry on connection error.\n\n\n    if (!res) {\n      return true;\n    } // The API may ask us not to retry (e.g., if doing so would be a no-op)\n    // or advise us to retry (e.g., in cases of lock timeouts); we defer to that.\n\n\n    if (res.getHeaders()['stripe-should-retry'] === 'false') {\n      return false;\n    }\n\n    if (res.getHeaders()['stripe-should-retry'] === 'true') {\n      return true;\n    } // Retry on conflict errors.\n\n\n    if (res.getStatusCode() === 409) {\n      return true;\n    } // Retry on 500, 503, and other internal errors.\n    //\n    // Note that we expect the stripe-should-retry header to be false\n    // in most cases when a 500 is returned, since our idempotency framework\n    // would typically replay it anyway.\n\n\n    if (res.getStatusCode() >= 500) {\n      return true;\n    }\n\n    return false;\n  },\n  _getSleepTimeInMS: function _getSleepTimeInMS(numRetries) {\n    var retryAfter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    var initialNetworkRetryDelay = this._stripe.getInitialNetworkRetryDelay();\n\n    var maxNetworkRetryDelay = this._stripe.getMaxNetworkRetryDelay(); // Apply exponential backoff with initialNetworkRetryDelay on the\n    // number of numRetries so far as inputs. Do not allow the number to exceed\n    // maxNetworkRetryDelay.\n\n\n    var sleepSeconds = Math.min(initialNetworkRetryDelay * Math.pow(numRetries - 1, 2), maxNetworkRetryDelay); // Apply some jitter by randomizing the value in the range of\n    // (sleepSeconds / 2) to (sleepSeconds).\n\n    sleepSeconds *= 0.5 * (1 + Math.random()); // But never sleep less than the base sleep seconds.\n\n    sleepSeconds = Math.max(initialNetworkRetryDelay, sleepSeconds); // And never sleep less than the time the API asks us to wait, assuming it's a reasonable ask.\n\n    if (Number.isInteger(retryAfter) && retryAfter <= MAX_RETRY_AFTER_WAIT) {\n      sleepSeconds = Math.max(sleepSeconds, retryAfter);\n    }\n\n    return sleepSeconds * 1000;\n  },\n  // Max retries can be set on a per request basis. Favor those over the global setting\n  _getMaxNetworkRetries: function _getMaxNetworkRetries() {\n    var settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return settings.maxNetworkRetries && Number.isInteger(settings.maxNetworkRetries) ? settings.maxNetworkRetries : this._stripe.getMaxNetworkRetries();\n  },\n  _defaultIdempotencyKey: function _defaultIdempotencyKey(method, settings) {\n    // If this is a POST and we allow multiple retries, ensure an idempotency key.\n    var maxRetries = this._getMaxNetworkRetries(settings);\n\n    if (method === 'POST' && maxRetries > 0) {\n      return \"stripe-node-retry-\".concat(utils.uuid4());\n    }\n\n    return null;\n  },\n  _makeHeaders: function _makeHeaders(auth, contentLength, apiVersion, clientUserAgent, method, userSuppliedHeaders, userSuppliedSettings) {\n    var defaultHeaders = {\n      // Use specified auth token or use default from this stripe instance:\n      Authorization: auth ? \"Bearer \".concat(auth) : this._stripe.getApiField('auth'),\n      Accept: 'application/json',\n      'Content-Type': 'application/x-www-form-urlencoded',\n      'User-Agent': this._getUserAgentString(),\n      'X-Stripe-Client-User-Agent': clientUserAgent,\n      'X-Stripe-Client-Telemetry': this._getTelemetryHeader(),\n      'Stripe-Version': apiVersion,\n      'Stripe-Account': this._stripe.getApiField('stripeAccount'),\n      'Idempotency-Key': this._defaultIdempotencyKey(method, userSuppliedSettings)\n    }; // As per https://datatracker.ietf.org/doc/html/rfc7230#section-3.3.2:\n    //   A user agent SHOULD send a Content-Length in a request message when\n    //   no Transfer-Encoding is sent and the request method defines a meaning\n    //   for an enclosed payload body.  For example, a Content-Length header\n    //   field is normally sent in a POST request even when the value is 0\n    //   (indicating an empty payload body).  A user agent SHOULD NOT send a\n    //   Content-Length header field when the request message does not contain\n    //   a payload body and the method semantics do not anticipate such a\n    //   body.\n    //\n    // These method types are expected to have bodies and so we should always\n    // include a Content-Length.\n\n    var methodHasPayload = method == 'POST' || method == 'PUT' || method == 'PATCH'; // If a content length was specified, we always include it regardless of\n    // whether the method semantics anticipate such a body. This keeps us\n    // consistent with historical behavior. We do however want to warn on this\n    // and fix these cases as they are semantically incorrect.\n\n    if (methodHasPayload || contentLength) {\n      if (!methodHasPayload) {\n        utils.emitWarning(\"\".concat(method, \" method had non-zero contentLength but no payload is expected for this verb\"));\n      }\n\n      defaultHeaders['Content-Length'] = contentLength;\n    }\n\n    return Object.assign(utils.removeNullish(defaultHeaders), // If the user supplied, say 'idempotency-key', override instead of appending by ensuring caps are the same.\n    utils.normalizeHeaders(userSuppliedHeaders));\n  },\n  _getUserAgentString: function _getUserAgentString() {\n    var packageVersion = this._stripe.getConstant('PACKAGE_VERSION');\n\n    var appInfo = this._stripe._appInfo ? this._stripe.getAppInfoAsString() : '';\n    return \"Stripe/v1 NodeBindings/\".concat(packageVersion, \" \").concat(appInfo).trim();\n  },\n  _getTelemetryHeader: function _getTelemetryHeader() {\n    if (this._stripe.getTelemetryEnabled() && this._stripe._prevRequestMetrics.length > 0) {\n      var metrics = this._stripe._prevRequestMetrics.shift();\n\n      return JSON.stringify({\n        last_request_metrics: metrics\n      });\n    }\n  },\n  _recordRequestMetrics: function _recordRequestMetrics(requestId, requestDurationMs) {\n    if (this._stripe.getTelemetryEnabled() && requestId) {\n      if (this._stripe._prevRequestMetrics.length > StripeResource.MAX_BUFFERED_REQUEST_METRICS) {\n        utils.emitWarning('Request metrics buffer is full, dropping telemetry message.');\n      } else {\n        this._stripe._prevRequestMetrics.push({\n          request_id: requestId,\n          request_duration_ms: requestDurationMs\n        });\n      }\n    }\n  },\n  _request: function _request(method, host, path, data, auth) {\n    var _this4 = this;\n\n    var options = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    var callback = arguments.length > 6 ? arguments[6] : undefined;\n    var requestData;\n\n    var retryRequest = function retryRequest(requestFn, apiVersion, headers, requestRetries, retryAfter) {\n      return setTimeout(requestFn, _this4._getSleepTimeInMS(requestRetries, retryAfter), apiVersion, headers, requestRetries + 1);\n    };\n\n    var makeRequest = function makeRequest(apiVersion, headers, numRetries) {\n      // timeout can be set on a per-request basis. Favor that over the global setting\n      var timeout = options.settings && Number.isInteger(options.settings.timeout) && options.settings.timeout >= 0 ? options.settings.timeout : _this4._stripe.getApiField('timeout');\n\n      var req = _this4._stripe.getApiField('httpClient').makeRequest(host || _this4._stripe.getApiField('host'), _this4._stripe.getApiField('port'), path, method, headers, requestData, _this4._stripe.getApiField('protocol'), timeout);\n\n      var requestStartTime = Date.now();\n      var requestEvent = utils.removeNullish({\n        api_version: apiVersion,\n        account: headers['Stripe-Account'],\n        idempotency_key: headers['Idempotency-Key'],\n        method: method,\n        path: path,\n        request_start_time: requestStartTime\n      });\n      var requestRetries = numRetries || 0;\n\n      var maxRetries = _this4._getMaxNetworkRetries(options.settings);\n\n      _this4._stripe._emitter.emit('request', requestEvent);\n\n      req.then(function (res) {\n        if (_this4._shouldRetry(res, requestRetries, maxRetries)) {\n          return retryRequest(makeRequest, apiVersion, headers, requestRetries, res.getHeaders()['retry-after']);\n        } else if (options.streaming && res.getStatusCode() < 400) {\n          return _this4._streamingResponseHandler(requestEvent, callback)(res);\n        } else {\n          return _this4._jsonResponseHandler(requestEvent, callback)(res);\n        }\n      }).catch(function (error) {\n        if (_this4._shouldRetry(null, requestRetries, maxRetries, error)) {\n          return retryRequest(makeRequest, apiVersion, headers, requestRetries, null);\n        } else {\n          var isTimeoutError = error.code && error.code === HttpClient.TIMEOUT_ERROR_CODE;\n          return callback.call(_this4, new StripeConnectionError({\n            message: isTimeoutError ? \"Request aborted due to timeout being reached (\".concat(timeout, \"ms)\") : _this4._generateConnectionErrorMessage(requestRetries),\n            detail: error\n          }));\n        }\n      });\n    };\n\n    var prepareAndMakeRequest = function prepareAndMakeRequest(error, data) {\n      if (error) {\n        return callback(error);\n      }\n\n      requestData = data;\n\n      _this4._stripe.getClientUserAgent(function (clientUserAgent) {\n        var apiVersion = _this4._stripe.getApiField('version');\n\n        var headers = _this4._makeHeaders(auth, requestData.length, apiVersion, clientUserAgent, method, options.headers, options.settings);\n\n        makeRequest(apiVersion, headers);\n      });\n    };\n\n    if (this.requestDataProcessor) {\n      this.requestDataProcessor(method, data, options.headers, prepareAndMakeRequest);\n    } else {\n      prepareAndMakeRequest(null, utils.stringifyRequestData(data || {}));\n    }\n  }\n};\nmodule.exports = StripeResource;","map":null,"metadata":{},"sourceType":"script"}